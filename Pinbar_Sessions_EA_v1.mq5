//+------------------------------------------------------------------+
//| MT5 EA: Pinbar_Sessions_EA                                       |
//| Description: Opens market position when a pinbar (rejection wick) |
//| is detected in London and New York sessions.                      |
//| Author: Generated by ChatGPT (user: Fikri)                        |
//| Notes: - Detects pinbar on the last closed candle (shift=1).      |
//|        - Opens trade on market on next tick.                      |
//+------------------------------------------------------------------+
#include <Trade\Trade.mqh>

CTrade trade;

#property copyright "ChatGPT"
#property version "1.00"
#property strict

//--- inputs
input double Lots = 0.01; // Fixed lot size (if UseMoneyManagement=false)
input bool UseMoneyManagement = true; // Use risk percent per trade
input double RiskPercent = 0.5; // % risk per trade (if UseMoneyManagement=true)
input int SlPips = 30; // Stop Loss in pips
input int TpPips = 60; // Take Profit in pips (0 = disabled)
input int MaxTradesPerSession = 1; // Max open trades in session
input int MagicNumber = 2016; // Magic number for EA trades
input int Slippage = 5; // Max slippage in points
input double MinRangePips = 10; // Minimum candle range (pips) to consider
input double BodyToRangeMax = 0.30; // Body must be <= this fraction of range
input double WickToRangeMin = 0.60; // One wick must be >= this fraction of range
input bool OnlyTradeOnBreakout = false; // Only trade if price breaks the candle high/low

// Session times are in server hours (0-23). Adjust if broker server time differs from local time.
input int LondonStartHour = 7; // London session start hour (server time)
input int LondonEndHour = 16; // London session end hour (server time)
input int NYStartHour = 12; // New York session start hour (server time)
input int NYEndHour = 22; // New York session end hour (server time)

input bool TradeLondon = true; // Enable London session trading
input bool TradeNewYork = true; // Enable New York session trading

input bool FilterSpread = true; // Filter by maximum spread
input int MaxSpreadPips = 20; // Max allowed spread in pips

input bool DisableAfterTrade = false; // Stop trading after opening one trade (useful for backtests)

//--- globals
ulong ticket_opened = 0;

//+------------------------------------------------------------------+
int OnInit() {
   Print("Pinbar_Sessions_EA initialized");
   return (INIT_SUCCEEDED);
}

//+------------------------------------------------------------------+
void OnTick() {
   static datetime lastChecked = 0;

   // operate only once per new tick that completes a candle (we use shift=1)
   datetime t = iTime(_Symbol, PERIOD_CURRENT, 1); // time of the last closed candle
   if (t == lastChecked) return; // nothing new
   lastChecked = t;

   // safety checks
   if (!TerminalInfoInteger(TERMINAL_CONNECTED)) return;
   if (!SymbolInfoDouble(_Symbol, SYMBOL_POINT)) return;

   // spread filter
   double spread = (SymbolInfoDouble(_Symbol, SYMBOL_ASK) - SymbolInfoDouble(_Symbol, SYMBOL_BID)) / SymbolInfoDouble(_Symbol, SYMBOL_POINT);
   if (FilterSpread && spread > MaxSpreadPips) return;

   // check sessions
   if (!IsDuringSessions(t)) return;

   // detect pinbar on closed candle (shift=1)
   int shift = 1;
   if (!IsPinBar(_Symbol, PERIOD_CURRENT, shift)) return;

   // limit number of trades
   if (CountOpenTradesInSession() >= MaxTradesPerSession) return;

   // decide direction
   bool bullish = IsBullishPinbar(_Symbol, PERIOD_CURRENT, shift);
   bool bearish = IsBearishPinbar(_Symbol, PERIOD_CURRENT, shift);

   if (!bullish && !bearish) return;

   // calculate lot size
   double lots = Lots;
   if (UseMoneyManagement) {
      lots = CalcLotByRisk(SlPips);
      if (lots <= 0) return;
   }

   // calculate prices
   double ask = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
   double bid = SymbolInfoDouble(_Symbol, SYMBOL_BID);
   double point = SymbolInfoDouble(_Symbol, SYMBOL_POINT);
   double sl = 0, tp = 0;

   if (bullish) {
      if (OnlyTradeOnBreakout) {
         double candleHigh = iHigh(_Symbol, PERIOD_CURRENT, shift);
         if (ask <= candleHigh) return; // waiting for breakout
      }

      sl = iLow(_Symbol, PERIOD_CURRENT, shift) - SlPips * point;
      if (TpPips > 0) tp = ask + TpPips * point;
      // place buy
      trade.SetExpertMagicNumber(MagicNumber);
      trade.SetDeviationInPoints(Slippage);
      bool ok = trade.Buy(lots, NULL, 0, sl, tp, "Pinbar Buy");
      if (ok) PrintFormat("Buy opened: lots=%.2f, SL=%.5f, TP=%.5f", lots, sl, tp);
      else PrintFormat("Buy failed: %s", trade.ResultComment());
   } else if (bearish) {
      if (OnlyTradeOnBreakout) {
         double candleLow = iLow(_Symbol, PERIOD_CURRENT, shift);
         if (bid >= candleLow) return; // waiting for breakout
      }

      sl = iHigh(_Symbol, PERIOD_CURRENT, shift) + SlPips * point;
      if (TpPips > 0) tp = bid - TpPips * point;
      // place sell
      trade.SetExpertMagicNumber(MagicNumber);
      trade.SetDeviationInPoints(Slippage);
      bool ok = trade.Sell(lots, NULL, 0, sl, tp, "Pinbar Sell");
      if (ok) PrintFormat("Sell opened: lots=%.2f, SL=%.5f, TP=%.5f", lots, sl, tp);
      else PrintFormat("Sell failed: %s", trade.ResultComment());
   }

   if (DisableAfterTrade) ExpertRemove(); // remove EA after trade
}

//+------------------------------------------------------------------+
bool IsDuringSessions(datetime candleTime) {
   MqlDateTime dt;
   TimeToStruct(candleTime, dt);
   int hour = dt.hour;

   bool inLondon = false, inNY = false;
   if (TradeLondon) {
      if (LondonStartHour <= LondonEndHour)
         inLondon = (hour >= LondonStartHour && hour <= LondonEndHour);
      else // wraps midnight
         inLondon = (hour >= LondonStartHour || hour <= LondonEndHour);
   }
   if (TradeNewYork) {
      if (NYStartHour <= NYEndHour)
         inNY = (hour >= NYStartHour && hour <= NYEndHour);
      else // wraps midnight
         inNY = (hour >= NYStartHour || hour <= NYEndHour);
   }
   return (inLondon || inNY);
}

//+------------------------------------------------------------------+
int CountOpenTradesInSession() {
   int count = 0;
   for (int i = 0; i < PositionsTotal(); i++) {
      ulong ticket = PositionGetTicket(i);
      if (PositionSelectByTicket(ticket)) {
         if (PositionGetInteger(POSITION_MAGIC) == MagicNumber && PositionGetString(POSITION_SYMBOL) == _Symbol)
            count++;
      }
   }
   return count;
}

//+------------------------------------------------------------------+
bool IsPinBar(const string symbol, ENUM_TIMEFRAMES timeframe, int shift) {
   double open = iOpen(symbol, timeframe, shift);
   double close = iClose(symbol, timeframe, shift);
   double high = iHigh(symbol, timeframe, shift);
   double low = iLow(symbol, timeframe, shift);

   double range = high - low;
   double body = MathAbs(open - close);

   double point = SymbolInfoDouble(symbol, SYMBOL_POINT);
   double rangePips = range / point;
   if (rangePips < MinRangePips) return false;

   if (body > range * BodyToRangeMax) return false; // body too large

   double upperWick = high - MathMax(open, close);
   double lowerWick = MathMin(open, close) - low;

   if (upperWick >= range * WickToRangeMin || lowerWick >= range * WickToRangeMin)
      return true;

   return false;
}

//+------------------------------------------------------------------+
bool IsBullishPinbar(const string symbol, ENUM_TIMEFRAMES timeframe, int shift) {

   int totalRequirements = 5;
   int requirementsMet = 0;
   
   // Requirements 1 : Candle Shift 1 must bullish
   
   double open = iOpen(symbol, timeframe, shift);
   double close = iClose(symbol, timeframe, shift);
   double high = iHigh(symbol, timeframe, shift);
   double low = iLow(symbol, timeframe, shift);

   double range = high - low;
   double upperWick = high - MathMax(open, close);
   double lowerWick = MathMin(open, close) - low;

   // bullish pinbar: long lower wick, close near high (Requirements 1)
   if (lowerWick >= range * WickToRangeMin && close > open) {
      requirementsMet = requirementsMet++;
   }
   
   // pinbar must bullish  (Requirements 2)
   if(close > open) {
      requirementsMet = requirementsMet++;
   }
   
   if(requirementsMet == totalRequirements) {
      return true;
   } else {
      return false;
   }
}

/*
bool IsBullishPinbar(const string symbol, ENUM_TIMEFRAMES timeframe, int shift) {
   double open = iOpen(symbol, timeframe, shift);
   double close = iClose(symbol, timeframe, shift);
   double high = iHigh(symbol, timeframe, shift);
   double low = iLow(symbol, timeframe, shift);

   double range = high - low;
   double upperWick = high - MathMax(open, close);
   double lowerWick = MathMin(open, close) - low;

   // bullish pinbar: long lower wick, close near high
   if (lowerWick >= range * WickToRangeMin && close > open) return true;
   return false;
}*/

//+------------------------------------------------------------------+
bool IsBearishPinbar(const string symbol, ENUM_TIMEFRAMES timeframe, int shift) {
   double open = iOpen(symbol, timeframe, shift);
   double close = iClose(symbol, timeframe, shift);
   double high = iHigh(symbol, timeframe, shift);
   double low = iLow(symbol, timeframe, shift);

   double range = high - low;
   double upperWick = high - MathMax(open, close);
   double lowerWick = MathMin(open, close) - low;

   // bearish pinbar: long upper wick, close near low
   if (upperWick >= range * WickToRangeMin && close < open) return true;
   return false;
}

//+------------------------------------------------------------------+
double CalcLotByRisk(int slPips) {
   // approximate calculation using ACCOUNT_BALANCE and symbol specifics
   double balance = AccountInfoDouble(ACCOUNT_BALANCE);
   double riskMoney = balance * (RiskPercent / 100.0);
   double point = SymbolInfoDouble(_Symbol, SYMBOL_POINT);
   double tickValue = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_VALUE);
   double tickSize = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_SIZE);

   // if tickValue unavailable, fallback to simple formula using contract size
   double contractSize = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_CONTRACT_SIZE);
   double price = SymbolInfoDouble(_Symbol, SYMBOL_BID);

   double slInPrice = slPips * point;
   double lot = 0;
   if (tickValue > 0 && tickSize > 0) {
      double valuePerPointPerLot = (tickValue / tickSize);
      lot = riskMoney / (slInPrice * valuePerPointPerLot);
   } else if (contractSize > 0 && price > 0) {
      // For FX: value per pip per lot roughly = contractSize * 0.0001 (for 4-digit)
      double pipValuePerLot = contractSize * 0.0001;
      if (SymbolInfoInteger(_Symbol, SYMBOL_DIGITS) == 5 || SymbolInfoInteger(_Symbol, SYMBOL_DIGITS) == 3)
         pipValuePerLot = contractSize * 0.00001; // 5-digit
      lot = riskMoney / (slPips * pipValuePerLot);
   }

   // ensure lot respects lot step and min/max
   double minLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
   double maxLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MAX);
   double lotStep = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);
   if (minLot <= 0) minLot = 0.01;
   if (lotStep <= 0) lotStep = 0.01;

   if (lot <= 0) return (0);
   // round down to nearest lot step
   lot = MathFloor(lot / lotStep) * lotStep;
   if (lot < minLot) lot = minLot;
   if (lot > maxLot) lot = maxLot;
   return NormalizeDouble(lot, 2);
}

//+------------------------------------------------------------------+
// End of file
//+------------------------------------------------------------------+
