//+------------------------------------------------------------------+
//| ImprovedPatternEA_v2.mq5                                        |
//| Fixed iMA usage (handle + CopyBuffer).                          |
//+------------------------------------------------------------------+
#property copyright "Generated by ChatGPT"
#property version   "1.10"
#property strict

#include <Trade\Trade.mqh>
CTrade trade;

//--- Inputs
input double maxRiskPercent       = 1.0;    // % risk per trade
input double maxDailyDDPercent    = 4.0;    // % max daily drawdown
input double fixedLotFallback     = 0.01;   // fallback lot if risk calc fails
input bool   useTrailingStop      = false;
input int    trailingStartPips    = 20;
input int    trailingStepPips     = 5;
input int    fastMAPeriod         = 20;
input int    slowMAPeriod         = 50;
input int    maTimeframe          = PERIOD_M15; // timeframe for MAs
input int    defaultSLpips        = 50;    // default SL (pips) used for lot calc if none available
input int    defaultTPpips        = 100;   // default TP (pips)

//--- Globals
int    handleFast = INVALID_HANDLE;
int    handleSlow = INVALID_HANDLE;
datetime day_start_date;
double day_start_balance = 0.0;

//+------------------------------------------------------------------+
//| Expert initialization                                            |
//+------------------------------------------------------------------+
int OnInit()
{
   // create MA handles for the current chart symbol
   handleFast = iMA(_Symbol, (ENUM_TIMEFRAMES)maTimeframe, fastMAPeriod, 0, MODE_EMA, PRICE_CLOSE);
   if(handleFast == INVALID_HANDLE) {
      Print("Failed to create fast MA handle for ", _Symbol);
      return INIT_FAILED;
   }

   handleSlow = iMA(_Symbol, (ENUM_TIMEFRAMES)maTimeframe, slowMAPeriod, 0, MODE_EMA, PRICE_CLOSE);
   if(handleSlow == INVALID_HANDLE) {
      Print("Failed to create slow MA handle for ", _Symbol);
      IndicatorRelease(handleFast);
      return INIT_FAILED;
   }

   day_start_date = DateOfDay(TimeCurrent());
   day_start_balance = AccountInfoDouble(ACCOUNT_BALANCE);

   PrintFormat("Init OK. Trading symbol=%s tf=%d fast=%d slow=%d", _Symbol, maTimeframe, fastMAPeriod, slowMAPeriod);
   return INIT_SUCCEEDED;
}

//+------------------------------------------------------------------+
//| Expert deinitialization                                          |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
{
   if(handleFast != INVALID_HANDLE) IndicatorRelease(handleFast);
   if(handleSlow != INVALID_HANDLE) IndicatorRelease(handleSlow);
}

//+------------------------------------------------------------------+
//| OnTick                                                            |
//+------------------------------------------------------------------+
void OnTick()
{
   // reset daily baseline at server midnight
   datetime now = TimeCurrent();
   if(DateOfDay(now) != day_start_date) {
      day_start_date = DateOfDay(now);
      day_start_balance = AccountInfoDouble(ACCOUNT_BALANCE);
      PrintFormat("New day baseline set: %.2f at %s", day_start_balance, TimeToString(day_start_date, TIME_DATE|TIME_MINUTES));
   }

   // check daily drawdown
   double current_balance = AccountInfoDouble(ACCOUNT_BALANCE);
   double dd_percent = 0.0;
   if(day_start_balance > 0.0) dd_percent = (day_start_balance - current_balance) / day_start_balance * 100.0;
   if(dd_percent >= maxDailyDDPercent) {
      // no new trades allowed
      return;
   }

   // apply trailing if position exists
   if(PositionsTotal() > 0) {
      if(useTrailingStop) ApplyTrailingStop();
      return;
   }

   // get MA values via CopyBuffer
   double maFast = 0.0, maSlow = 0.0;
   if(!GetMAValue(handleFast, 0, maFast)) return; // if failed, abort
   if(!GetMAValue(handleSlow, 0, maSlow)) return;

   // simple EMA cross strategy (example "pattern" derived rule)
   if(maFast > maSlow + SymbolInfoDouble(_Symbol, SYMBOL_POINT) * 1.0) {
      // BUY condition
      PlaceBuy();
   } else if(maFast < maSlow - SymbolInfoDouble(_Symbol, SYMBOL_POINT) * 1.0) {
      // SELL condition
      PlaceSell();
   }
}

//+------------------------------------------------------------------+
//| Helper: get single MA value from handle                          |
//+------------------------------------------------------------------+
bool GetMAValue(int handle, int shift, double &value[])
{
   if(handle == INVALID_HANDLE) return false;
   // Copy 1 value starting at position 'shift' (0 = current)
   double buf[];
   int copied = CopyBuffer(handle, 0, shift, 1, buf);
   if(copied <= 0) {
      // sometimes indicator data isn't ready yet
      // Print("CopyBuffer failed for handle=", handle, " copied=", copied);
      return false;
   }
   ArrayResize(value,1);
   value[0] = buf[0];
   return true;
}

// overload convenience to return single double
bool GetMAValue(int handle, int shift, double &outValue)
{
   double tmp[];
   bool ok = GetMAValue(handle, shift, tmp);
   if(!ok) return false;
   outValue = tmp[0];
   return true;
}

//+------------------------------------------------------------------+
//| Place Buy with lot calc based on defaultSLpips                   |
//+------------------------------------------------------------------+
void PlaceBuy()
{
   double price = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
   double sl_price = price - defaultSLpips * SymbolInfoDouble(_Symbol, SYMBOL_POINT);
   double tp_price = price + defaultTPpips * SymbolInfoDouble(_Symbol, SYMBOL_POINT);
   double lot = CalculateLotFromRisk(defaultSLpips);

   trade.SetExpertMagicNumber(123456);
   trade.SetDeviationInPoints(50);
   bool res = trade.Buy(lot, _Symbol, 0.0, sl_price, tp_price, "ImpEA_Buy");
   if(res) PrintFormat("Buy opened: %.2f lots %s", lot, _Symbol);
   else PrintFormat("Buy failed: %s", trade.ResultComment());
}

//+------------------------------------------------------------------+
//| Place Sell                                                         |
//+------------------------------------------------------------------+
void PlaceSell()
{
   double price = SymbolInfoDouble(_Symbol, SYMBOL_BID);
   double sl_price = price + defaultSLpips * SymbolInfoDouble(_Symbol, SYMBOL_POINT);
   double tp_price = price - defaultTPpips * SymbolInfoDouble(_Symbol, SYMBOL_POINT);
   double lot = CalculateLotFromRisk(defaultSLpips);

   trade.SetExpertMagicNumber(123456);
   trade.SetDeviationInPoints(50);
   bool res = trade.Sell(lot, _Symbol, 0.0, sl_price, tp_price, "ImpEA_Sell");
   if(res) PrintFormat("Sell opened: %.2f lots %s", lot, _Symbol);
   else PrintFormat("Sell failed: %s", trade.ResultComment());
}

//+------------------------------------------------------------------+
//| Calculate lot size from risk (using SL pips)                     |
//+------------------------------------------------------------------+
double CalculateLotFromRisk(int slPips)
{
   double lot = fixedLotFallback;
   if(slPips <= 0) return lot;

   double tick_value = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_VALUE);
   double tick_size  = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_SIZE);
   double pip_value_per_lot = 0.0;
   if(tick_size > 0.0) pip_value_per_lot = tick_value / tick_size;

   double riskUsd = AccountInfoDouble(ACCOUNT_BALANCE) * (maxRiskPercent / 100.0);
   double riskUsdPerLot = slPips * SymbolInfoDouble(_Symbol, SYMBOL_POINT) * pip_value_per_lot;

   if(riskUsdPerLot > 0.0) {
      lot = riskUsd / riskUsdPerLot;
      // normalize to allowed volume
      double minLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
      double maxLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MAX);
      double step   = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);
      if(step <= 0.0) step = 0.01;
      lot = MathMax(lot, minLot);
      lot = MathMin(lot, maxLot);
      lot = MathFloor(lot/step) * step;
      if(lot < minLot) lot = minLot;
   }
   return lot;
}

//+------------------------------------------------------------------+
//| Simple trailing stop across positions                            |
//+------------------------------------------------------------------+
void ApplyTrailingStop()
{
   for(int i=0; i<PositionsTotal(); i++) {
      ulong ticket = PositionGetTicket(i);
      if(!PositionSelectByTicket(ticket)) continue;
      string sym = PositionGetString(POSITION_SYMBOL);
      if(sym != _Symbol) continue; // manage current chart symbol only
      long type = PositionGetInteger(POSITION_TYPE);
      double open_price = PositionGetDouble(POSITION_PRICE_OPEN);
      double current = (type == POSITION_TYPE_BUY) ? SymbolInfoDouble(sym, SYMBOL_BID)
                                                   : SymbolInfoDouble(sym, SYMBOL_ASK);
      double current_sl = PositionGetDouble(POSITION_SL);
      double profitPips = (type == POSITION_TYPE_BUY) ? (current - open_price) / SymbolInfoDouble(sym, SYMBOL_POINT)
                                                      : (open_price - current) / SymbolInfoDouble(sym, SYMBOL_POINT);
      if(profitPips > trailingStartPips) {
         double new_sl = (type == POSITION_TYPE_BUY) ? (current - trailingStepPips * SymbolInfoDouble(sym, SYMBOL_POINT))
                                                     : (current + trailingStepPips * SymbolInfoDouble(sym, SYMBOL_POINT));
         // only move SL in profit direction
         if((type == POSITION_TYPE_BUY && new_sl > current_sl) || (type == POSITION_TYPE_SELL && new_sl < current_sl)) {
            trade.PositionModify(ticket, new_sl, PositionGetDouble(POSITION_TP));
            PrintFormat("Trailing SL moved for ticket %d newSL=%.5f", ticket, new_sl);
         }
      }
   }
}

//+------------------------------------------------------------------+
//| DateOfDay helper (midnight server time)                          |
//+------------------------------------------------------------------+
datetime DateOfDay(datetime t)
{
   MqlDateTime d;
   TimeToStruct(t, d);
   d.hour = 0; d.min = 0; d.sec = 0;
   return StructToTime(d);
}
