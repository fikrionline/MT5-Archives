//+------------------------------------------------------------------+
//| PropFirm_EA.mq5                                                 |
//| A conservative MT5 Expert Advisor built to meet typical prop    |
//| firm challenge requirements: low risk per trade, strict DD checks|
//| Strategy: EMA crossover filtered by ATR volatility + time filter |
//| Position sizing: fixed % risk per trade based on SL (no martingale)
//| Author: Generated by GPT (example). Test thoroughly before use. |
//+------------------------------------------------------------------+
#property copyright "Generated by GPT"
#property link      ""
#property version   "1.00"
#property strict
#property description "Conservative EA for prop-firm style challenges. Use demo first."

#include <Trade\Trade.mqh>
CTrade trade;

input double  InpRiskPercent       = 1.0;            // Risk per trade (percent of balance)
input int     InpFastEMA           = 21;             // Fast EMA period
input int     InpSlowEMA           = 55;             // Slow EMA period
input int     InpATRPeriod         = 14;             // ATR period
input double  InpATRMultiplier     = 1.5;            // ATR multiplier for SL/TP
input double  InpMaxDailyDDPercent = 5.0;            // Max daily drawdown percent (stop trading for day)
input double  InpMaxOverallDDPercent = 10.0;         // Max overall drawdown percent (stop EA)
input ENUM_TIMEFRAMES InpTF       = PERIOD_M15;      // Timeframe used for signals
input bool    InpAllowLong         = true;           // Allow long trades
input bool    InpAllowShort        = true;           // Allow short trades
input int     InpStartHour         = 7;              // Start hour (server time)
input int     InpEndHour           = 22;             // End hour (server time)
input double  InpMaxLot            = 5;            // Absolute max lot size
input double  InpMinLot            = 0.01;           // Minimum lot size
input int     InpMaxTrades         = 1;              // Max concurrent trades on same symbol
input int     InpMagicNumber       = 20250919;       // Magic number
input int     InpSlippage          = 5;              // Max slippage in points

//--- internal
string TradeSymbol;
int    maFastHandle = INVALID_HANDLE;
int    maSlowHandle = INVALID_HANDLE;
int    atrHandle    = INVALID_HANDLE;
datetime day_start_time=0;
double day_start_balance=0.0;
//+------------------------------------------------------------------+
int OnInit()
  {
   TradeSymbol = (StringLen(TradeSymbol) == 0) ? _Symbol : TradeSymbol;

   // create indicator handles (MQL5: iMA/iATR return handles; use CopyBuffer to read values)
   maFastHandle = iMA(TradeSymbol, InpTF, InpFastEMA, 0, MODE_EMA, PRICE_CLOSE);
   if(maFastHandle == INVALID_HANDLE)
     {
      Print("Failed to create Fast EMA handle. Error=", GetLastError());
      return(INIT_FAILED);
     }

   maSlowHandle = iMA(TradeSymbol, InpTF, InpSlowEMA, 0, MODE_EMA, PRICE_CLOSE);
   if(maSlowHandle == INVALID_HANDLE)
     {
      Print("Failed to create Slow EMA handle. Error=", GetLastError());
      IndicatorRelease(maFastHandle);
      return(INIT_FAILED);
     }

   atrHandle = iATR(TradeSymbol, InpTF, InpATRPeriod);
   if(atrHandle == INVALID_HANDLE)
     {
      Print("Failed to create ATR handle. Error=", GetLastError());
      IndicatorRelease(maFastHandle);
      IndicatorRelease(maSlowHandle);
      return(INIT_FAILED);
     }

   day_start_time = iTime(TradeSymbol, PERIOD_D1, 0);
   day_start_balance = AccountInfoDouble(ACCOUNT_BALANCE);
   Print("PropFirm_EA initialized for symbol: ", TradeSymbol);
   return(INIT_SUCCEEDED);
  }

//+------------------------------------------------------------------+
void OnTick()
  {
   static datetime last_bar_time=0;

   // Check if new day started to reset daily start balance/time
   datetime cur_day = iTime(TradeSymbol, PERIOD_D1, 0);
   if(cur_day != day_start_time)
     {
      day_start_time = cur_day;
      day_start_balance = AccountInfoDouble(ACCOUNT_BALANCE);
     }

   // Safety: check overall & daily drawdown
   double balance = AccountInfoDouble(ACCOUNT_BALANCE);
   double equity = AccountInfoDouble(ACCOUNT_EQUITY);
   double daily_dd = 100.0 * (day_start_balance - equity) / day_start_balance;
   double overall_dd = 100.0 * (AccountInfoDouble(ACCOUNT_BALANCE) - equity) / AccountInfoDouble(ACCOUNT_BALANCE);

   if(daily_dd > InpMaxDailyDDPercent)
     {
      // exceeded daily drawdown
      Print("Daily drawdown exceeded: ",DoubleToString(daily_dd,2),"% - no more trades today.");
      return;
     }

   if(overall_dd > InpMaxOverallDDPercent)
     {
      Print("Overall drawdown exceeded: ",DoubleToString(overall_dd,2),"% - EA stopped.");
      return;
     }

   // Trading hours check
   MqlDateTime dt; TimeToStruct(TimeCurrent(), dt);
   int hour = dt.hour;
   if(!IsWithinHours(hour)) return;

   // Avoid multiple operate inside same bar: we evaluate on new signal on timeframe InpTF
   datetime bar_time = iTime(TradeSymbol, InpTF, 0);
   if(bar_time==last_bar_time) return; // already processed
   last_bar_time = bar_time;

   // Count open trades for this symbol & magic
   int open_count = CountOpenTrades(TradeSymbol, InpMagicNumber);
   if(open_count >= InpMaxTrades) return;

   // Read indicators via indicator handles (MQL5 style)
   double emaFastBuf[2];
   double emaSlowBuf[2];
   double atrBuf[1];

   if(CopyBuffer(maFastHandle, 0, 0, 2, emaFastBuf) != 2)
     {
      Print("Failed to copy Fast EMA buffer: ", GetLastError());
      return;
     }
   if(CopyBuffer(maSlowHandle, 0, 0, 2, emaSlowBuf) != 2)
     {
      Print("Failed to copy Slow EMA buffer: ", GetLastError());
      return;
     }
   if(CopyBuffer(atrHandle, 0, 0, 1, atrBuf) != 1)
     {
      Print("Failed to copy ATR buffer: ", GetLastError());
      return;
     }

   double emaFastCurr = emaFastBuf[0];
   double emaFastPrev = emaFastBuf[1];
   double emaSlowCurr = emaSlowBuf[0];
   double emaSlowPrev = emaSlowBuf[1];
   double atr = atrBuf[0];

   if(atr <= 0) return;

   // Determine crossover signal
   bool bullishCross = (emaFastPrev <= emaSlowPrev) && (emaFastCurr > emaSlowCurr);
   bool bearishCross = (emaFastPrev >= emaSlowPrev) && (emaFastCurr < emaSlowCurr);

   // Price & point
   double price = SymbolInfoDouble(TradeSymbol, SYMBOL_BID);
   double point = SymbolInfoDouble(TradeSymbol, SYMBOL_POINT);

   // Stop loss in points based on ATR
   double sl_pips = atr * InpATRMultiplier / point; // actually in points
   if(sl_pips < 10) sl_pips = 10; // minimum

   // position size calculation
   if(bullishCross && InpAllowLong)
     {
      double stoploss = price - (atr * InpATRMultiplier);
      double takeprofit = price + (atr * InpATRMultiplier * 2.0);
      double lots = CalculateLotByRisk(TradeSymbol, stoploss, InpRiskPercent, InpMinLot, InpMaxLot);
      if(lots <= 0) return;
      // send buy order
      trade.SetExpertMagicNumber(InpMagicNumber);
      trade.SetDeviationInPoints(InpSlippage);
      bool ok = trade.Buy(lots, TradeSymbol, price, stoploss, takeprofit, "PF_EA_Buy");
      if(ok) Print("Opened BUY: lots=",DoubleToString(lots,2)," SL=",DoubleToString(stoploss,Digits())," TP=",DoubleToString(takeprofit,Digits()));
      else Print("Buy failed: ",trade.ResultRetcode()," ",trade.ResultRetcodeDescription());
     }
   else if(bearishCross && InpAllowShort)
     {
      double priceAsk = SymbolInfoDouble(TradeSymbol, SYMBOL_ASK);
      double stoploss = priceAsk + (atr * InpATRMultiplier);
      double takeprofit = priceAsk - (atr * InpATRMultiplier * 2.0);
      double lots = CalculateLotByRisk(TradeSymbol, stoploss, InpRiskPercent, InpMinLot, InpMaxLot);
      if(lots <= 0) return;
      trade.SetExpertMagicNumber(InpMagicNumber);
      trade.SetDeviationInPoints(InpSlippage);
      bool ok = trade.Sell(lots, TradeSymbol, priceAsk, stoploss, takeprofit, "PF_EA_Sell");
      if(ok) Print("Opened SELL: lots=",DoubleToString(lots,2)," SL=",DoubleToString(stoploss,Digits())," TP=",DoubleToString(takeprofit,Digits()));
      else Print("Sell failed: ",trade.ResultRetcode()," ",trade.ResultRetcodeDescription());
     }
  }

//+------------------------------------------------------------------+
bool IsWithinHours(int hour)
  {
   if(InpStartHour <= InpEndHour)
     return (hour >= InpStartHour && hour <= InpEndHour);
   // wrap around midnight
   return (hour >= InpStartHour || hour <= InpEndHour);
  }

//+------------------------------------------------------------------+
int CountOpenTrades(string symbol, int magic)
  {
   int total=0;
   for(int i=0;i<PositionsTotal();i++)
     {
      ulong ticket = PositionGetTicket(i);
      if(PositionSelectByTicket(ticket))
        {
         string sym = PositionGetString(POSITION_SYMBOL);
         long  mg = PositionGetInteger(POSITION_MAGIC);
         if(sym==symbol && (int)mg==magic) total++;
        }
     }
   return total;
  }

//+------------------------------------------------------------------+
double CalculateLotByRisk(string symbol, double stop_price, double risk_percent, double minLot, double maxLot)
  {
   double balance = AccountInfoDouble(ACCOUNT_BALANCE);
   double riskAmount = balance * (risk_percent/100.0);
   // get current price & point
   double bid = SymbolInfoDouble(symbol, SYMBOL_BID);
   double ask = SymbolInfoDouble(symbol, SYMBOL_ASK);
   double price = (bid+ask)/2.0;
   double stopDistance = MathAbs(price - stop_price);
   if(stopDistance<=0) return(0);

   // value per lot in account currency
   double lotStep = SymbolInfoDouble(symbol, SYMBOL_VOLUME_STEP);
   double min_step = SymbolInfoDouble(symbol, SYMBOL_VOLUME_MIN);
   double pipValuePerLot = SymbolInfoDouble(symbol, SYMBOL_TRADE_TICK_VALUE);
   double tickSize = SymbolInfoDouble(symbol, SYMBOL_TRADE_TICK_SIZE);
   if(pipValuePerLot<=0 || tickSize<=0)
     {
      // fallback: estimate using margin and standard contract (risky)
      pipValuePerLot = 10.0; // generic fallback
      tickSize = SymbolInfoDouble(symbol, SYMBOL_POINT);
     }

   double stopsInTicks = stopDistance / tickSize;
   double valuePerLotPerTick = pipValuePerLot;
   double lot = riskAmount / (stopsInTicks * valuePerLotPerTick);

   // normalize to symbol lot step
   if(lot < minLot) lot = minLot;
   double normalized = MathFloor(lot/lotStep)*lotStep;
   if(normalized < minLot) normalized = minLot;
   if(normalized > maxLot) normalized = maxLot;
   // ensure respect broker limits
   double maxAllowed = SymbolInfoDouble(symbol, SYMBOL_VOLUME_MAX);
   if(normalized > maxAllowed) normalized = maxAllowed;
   return(NormalizeDouble(normalized,2));
  }

//+------------------------------------------------------------------+
void OnDeinit(const int reason)
  {
   Print("PropFirm_EA deinitialized.");
  }

//+------------------------------------------------------------------+
// Notes:
// - This EA is intentionally conservative: no martingale, single trade filter, strict SL.
// - **Test extensively** in Strategy Tester and on demo under your prop-firm rules.
// - Adjust InpRiskPercent to meet the prop-firm max daily/overall drawdown rules.
// - Do not run multiple instances on same symbol with same magic number.
//+------------------------------------------------------------------+
