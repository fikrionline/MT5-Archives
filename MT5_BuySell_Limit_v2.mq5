//+------------------------------------------------------------------+
//|                                                 MT5_BuySell.mq5 |
//|                         Generated by ChatGPT                    |
//+------------------------------------------------------------------+
#property strict

input double   InpRiskPercent     = 0.5;       // Risk per trade (% equity)
input double   InpMinLot          = 0.01;      // Minimum lot size
input int      InpTrailingPointsBuy  = 100;    // Trailing stop points for Buy
input int      InpTrailingPointsSell = 100;    // Trailing stop points for Sell
input int      LondonStartHour    = 8;         // London session start (server time)
input int      LondonEndHour      = 17;        // London session end
input int      NewYorkStartHour   = 13;        // New York session start
input int      NewYorkEndHour     = 22;        // New York session end
input ENUM_TIMEFRAMES InpSignalTF = PERIOD_H1; // Timeframe for signal logic
input long     InpMagicBuy        = 10001;     // Magic number for Buy Limit
input long     InpMagicSell       = 10002;     // Magic number for Sell Limit

string BuyComment  = "EA_BUY_LIMIT_H1";
string SellComment = "EA_SELL_LIMIT_H1";

//--- function to check trading session
bool IsInTradingSession()
  {
   datetime now = TimeCurrent();
   MqlDateTime t;
   TimeToStruct(now, t);
   int hour = t.hour;

   if(hour >= LondonStartHour && hour < LondonEndHour) return true;
   if(hour >= NewYorkStartHour && hour < NewYorkEndHour) return true;
   return false;
  }

//--- lot size calculation
 double CalculateLot(double stopPoints)
  {
   double equity      = AccountInfoDouble(ACCOUNT_EQUITY);
   double riskAmount  = equity * InpRiskPercent / 100.0;
   double tickSize    = SymbolInfoDouble(_Symbol,SYMBOL_TRADE_TICK_SIZE);
   double tickValue   = SymbolInfoDouble(_Symbol,SYMBOL_TRADE_TICK_VALUE);
   double contractSize= SymbolInfoDouble(_Symbol,SYMBOL_TRADE_CONTRACT_SIZE);
   double lotStep     = SymbolInfoDouble(_Symbol,SYMBOL_VOLUME_STEP);
   double minLot      = SymbolInfoDouble(_Symbol,SYMBOL_VOLUME_MIN);

   double valuePerLot = (stopPoints * _Point / tickSize) * tickValue;
   double lots        = riskAmount / valuePerLot;

   lots = MathMax(lots,InpMinLot);
   lots = MathFloor(lots/lotStep)*lotStep;
   return NormalizeDouble(lots,2);
  }

//--- get today's lowest open
 double GetTodayLowestOpen()
  {
   datetime todayStart = StringToTime(TimeToString(TimeCurrent(), TIME_DATE));
   datetime tomorrowStart = todayStart + 86400;

   double lowestOpen = DBL_MAX;
   for(int i=0; i<Bars(_Symbol, InpSignalTF); i++)
     {
      datetime barTime = iTime(_Symbol, InpSignalTF, i);
      if(barTime < todayStart) break;
      if(barTime >= todayStart && barTime < tomorrowStart)
        {
         double op = iOpen(_Symbol, InpSignalTF, i);
         if(op < lowestOpen) lowestOpen = op;
        }
     }
   return lowestOpen;
  }

//--- get today's highest open
 double GetTodayHighestOpen()
  {
   datetime todayStart = StringToTime(TimeToString(TimeCurrent(), TIME_DATE));
   datetime tomorrowStart = todayStart + 86400;

   double highestOpen = -DBL_MAX;
   for(int i=0; i<Bars(_Symbol, InpSignalTF); i++)
     {
      datetime barTime = iTime(_Symbol, InpSignalTF, i);
      if(barTime < todayStart) break;
      if(barTime >= todayStart && barTime < tomorrowStart)
        {
         double op = iOpen(_Symbol, InpSignalTF, i);
         if(op > highestOpen) highestOpen = op;
        }
     }
   return highestOpen;
  }

//--- place Buy Limit
void PlaceBuyLimitFromTodayLowestOpen()
  {
   double lowestOpen = GetTodayLowestOpen();
   if(lowestOpen==DBL_MAX) return;

   double candleHigh=iHigh(_Symbol,InpSignalTF,1);
   double candleLow =iLow(_Symbol,InpSignalTF,1);
   double stopPoints=(candleHigh-candleLow)/_Point;
   double sl=lowestOpen-stopPoints*_Point;
   double tp=lowestOpen+stopPoints*_Point;
   double lot=CalculateLot(stopPoints);

   MqlTradeRequest req;
   MqlTradeResult  res;
   ZeroMemory(req);
   ZeroMemory(res);

   req.action   = TRADE_ACTION_PENDING;
   req.type     = ORDER_TYPE_BUY_LIMIT;
   req.symbol   = _Symbol;
   req.volume   = lot;
   req.price    = lowestOpen;
   req.sl       = sl;
   req.tp       = tp;
   req.deviation= 20;
   req.magic    = InpMagicBuy;
   req.comment  = BuyComment;
   req.type_filling = ORDER_FILLING_FOK;
   req.type_time    = ORDER_TIME_GTC;

   if(!OrderSend(req,res))
      PrintFormat("BuyLimit OrderSend failed. Retcode=%d",res.retcode);
   else
      PrintFormat("BuyLimit placed. Ticket=%I64u",res.order);
  }

//--- place Sell Limit
void PlaceSellLimitFromTodayHighestOpen()
  {
   double highestOpen = GetTodayHighestOpen();
   if(highestOpen==-DBL_MAX) return;

   double candleHigh=iHigh(_Symbol,InpSignalTF,1);
   double candleLow =iLow(_Symbol,InpSignalTF,1);
   double stopPoints=(candleHigh-candleLow)/_Point;
   double sl=highestOpen+stopPoints*_Point;
   double tp=highestOpen-stopPoints*_Point;
   double lot=CalculateLot(stopPoints);

   MqlTradeRequest req;
   MqlTradeResult  res;
   ZeroMemory(req);
   ZeroMemory(res);

   req.action   = TRADE_ACTION_PENDING;
   req.type     = ORDER_TYPE_SELL_LIMIT;
   req.symbol   = _Symbol;
   req.volume   = lot;
   req.price    = highestOpen;
   req.sl       = sl;
   req.tp       = tp;
   req.deviation= 20;
   req.magic    = InpMagicSell;
   req.comment  = SellComment;
   req.type_filling = ORDER_FILLING_FOK;
   req.type_time    = ORDER_TIME_GTC;

   if(!OrderSend(req,res))
      PrintFormat("SellLimit OrderSend failed. Retcode=%d",res.retcode);
   else
      PrintFormat("SellLimit placed. Ticket=%I64u",res.order);
  }

//--- manage trailing stops
void ManageTrailingStops()
  {
   for(int i=PositionsTotal()-1; i>=0; i--)
     {
      ulong ticket=PositionGetTicket(i);
      if(!PositionSelectByTicket(ticket)) continue;

      string sym=PositionGetString(POSITION_SYMBOL);
      if(sym!=_Symbol) continue;

      long magic=PositionGetInteger(POSITION_MAGIC);
      double priceOpen=PositionGetDouble(POSITION_PRICE_OPEN);
      double volume=PositionGetDouble(POSITION_VOLUME);
      double sl=PositionGetDouble(POSITION_SL);
      double currentPrice=SymbolInfoDouble(_Symbol,(magic==InpMagicBuy)?SYMBOL_BID:SYMBOL_ASK);

      int trailing=(magic==InpMagicBuy)?InpTrailingPointsBuy:InpTrailingPointsSell;

      MqlTradeRequest req;
      MqlTradeResult res;
      ZeroMemory(req);
      ZeroMemory(res);

      if(PositionGetInteger(POSITION_TYPE)==POSITION_TYPE_BUY)
        {
         double newSL=currentPrice-trailing*_Point;
         if(newSL>sl)
           {
            req.action=TRADE_ACTION_SLTP;
            req.symbol=_Symbol;
            req.volume=volume;
            req.sl=newSL;
            req.tp=PositionGetDouble(POSITION_TP);
            req.magic=magic;
            if(!OrderSend(req,res))
               PrintFormat("Trailing SL update failed for Buy. Retcode=%d",res.retcode);
           }
        }
      else if(PositionGetInteger(POSITION_TYPE)==POSITION_TYPE_SELL)
        {
         double newSL=currentPrice+trailing*_Point;
         if(sl==0 || newSL<sl)
           {
            req.action=TRADE_ACTION_SLTP;
            req.symbol=_Symbol;
            req.volume=volume;
            req.sl=newSL;
            req.tp=PositionGetDouble(POSITION_TP);
            req.magic=magic;
            if(!OrderSend(req,res))
               PrintFormat("Trailing SL update failed for Sell. Retcode=%d",res.retcode);
           }
        }
     }
  }

//--- OnTick
void OnTick()
  {
   if(!IsInTradingSession()) return;

   static datetime lastBarTime=0;
   datetime currentBar=iTime(_Symbol,InpSignalTF,0);

   if(currentBar!=lastBarTime)
     {
      // Delete expired pending orders
      for(int i=OrdersTotal()-1;i>=0;i--)
        {
         ulong ticket=OrderGetTicket(i);
         if(!OrderSelect(ticket)) continue;

         long type=OrderGetInteger(ORDER_TYPE);
         string com=OrderGetString(ORDER_COMMENT);
         long magic=OrderGetInteger(ORDER_MAGIC);

         if((type==ORDER_TYPE_BUY_LIMIT && magic==InpMagicBuy && StringFind(com,BuyComment)==0) ||
            (type==ORDER_TYPE_SELL_LIMIT && magic==InpMagicSell && StringFind(com,SellComment)==0))
           {
            MqlTradeRequest req;
            MqlTradeResult res;
            ZeroMemory(req);
            ZeroMemory(res);
            req.action=TRADE_ACTION_REMOVE;
            req.order=ticket;
            if(!OrderSend(req,res))
               PrintFormat("Order delete failed. Retcode=%d",res.retcode);
           }
        }

      // Place new orders
      PlaceBuyLimitFromTodayLowestOpen();
      PlaceSellLimitFromTodayHighestOpen();

      lastBarTime=currentBar;
     }

   ManageTrailingStops();
  }
